@ngdoc overview
@name Модульное тестирование
@description

# Модульное тестирование с angular-translate

Разработчики AngularJS уделяют внимание тестируемости кода. И нам это нравится. Поэтому мы тестируем 
angular-translate буквально с первых стадий разработки. Однако, при создании AngularJS приложений с 
поддержкой интернационализации от angular-translate тестирование вашего приложения может несколько 
усложниться. Это руководство покажет вам как можно обойти наиболее распространенные проблемы при 
написании модульных тестов для приложения, использующего angular-translate.

## В чем проблема?

Исходя из опыта разработки angular-translate, когда дело касается тестирования возникает одна и та 
же проблема. Представьте себе следующий сценарий: Вы создаете приложение, которое использует не
только сам angular-translate, но еще и асинхронный загрузчик (довольно распространенная ситуация).
Тогда конфигурация вашего приложения может выглядеть так:

<pre>
app.config(function ($translateProvider) {
  $translateProvider
    .useStaticFilesLoader({
      prefix: 'locale-',
      suffix: '.json'
    })
    .preferredLanguage('en');
});
</pre>

В таком случае мы используем загрузчик статических файлов для загрузки переводов с удаленной точки
доступа. Также мы говорим angular-translate, что предпочитаем использовать язык `en`. Все довольно
просто.

Давайте предположим, что у нас есть контроллер, который использует сервис `$translate` для 
переключения языка во время выполнения приложения (тоже *очень* распространено):

<pre>
app.controller('LanguageController', function ($scope, $translate) {
  $scope.switchLanguage = function (locale) {
    $translate.use(locale);
  });
});
</pre>

Хорошо. А теперь давайте подумаем что случится когда мы запустим наше приложение. Вот как все будет
происходить шаг за шагом:

- мы регистрируем асинхронный загрузчик
- мы указываем предпочитаемый нами язык
- сервис `$translate` впервые создается и внедряется
- angular-translate замечает, что нет локально доступных языков
- он проверяет зарегистрирован ли асинхронный загрузчик
- асинхронный загрузчик вызывается для предпочитаемого языка
- переводы загружаются и готовы к использованию

Полезно понимать как работает angular-translate, чтобы представить себе какие проблемы это может
вызвать. В представленом выше процессе есть один очень важный шаг. Если зарегистрирован асинхронный
загрузчик, а данные переводов еще не закешированы, то angular-translate **неявно** вызывает 
этот загрузчик. Почему же это может повлечь проблемы при модульном тестировании вашего приложения?

Чтобы это понять нам нужно взглянуть на то, как мы пишем тесты, например, с Jasmine. Мы начинаем с
блока `describe()` и загружаем наше angular приложение для каждого теста:

<pre>
describe('myApp', function () {

  beforeEach(module('myApp'));

});
</pre>

Благодаря этому мы можем быть уверены, что в каждом конкретном тесте создан модуль нашего
приложения. После этого мы настраиваем наш `LanguageController` с подменой области видимости
примерно так:

<pre>
describe('myApp', function () {

  beforeEach(module('myApp'));

  var LanguageCtrl, scope;

  beforeEach(inject(function ($controller, $rootScope) {
    scope = $rootScope.$new();

    LanguageCtrl = $controller('LanguageCtrl', {
      $scope: scope
    });
  }));

  it('should do something', function () {

  });
});
</pre>

При запуске этого теста мы получим следующую ошибку:

```
Error: Unexpected request: GET locale-en.json
```

Но почему? Проблема в том, что angular-translate неявно вызывает асинхронный загрузчик. Это значит,
что при создании сервиса `$translate` происходит асинхронный запрос на сервер, в отношении которого
мы ничего не делаем.

При написании тестов нужно явно указывать, что мы ожидаем выполнение асинхронного запроса в 
каждом конкретном случае. Так делать правильно. Другими словами, когда мы явно говорим, что ожидаем
асинхронный запрос, эта ошибка не должна возникать, так?

Давайте попробуем обойти эту проблему путем внедрения сервиса `$httpBackend` для обработки
асинхронных запросов и подставновки ответов:

<pre>
describe('myApp', function () {

  beforeEach(module('myApp'));

  var LanguageCtrl, scope, $httpBackend;

  beforeEach(inject(function ($controller, $rootScope, _$httpBackend_) {
    scope = $rootScope.$new();
    $httpBackend = _$httpBackend_;

    LanguageCtrl = $controller('LanguageCtrl', {
      $scope: scope
    });
  }));

  it('should do something', function () {
    $httpBackend.expectGET('locale-en.json');

    // test code goes here
  });
});
</pre>

Оказывается это тоже не работает, потому что в момент вызова `expectGET()` асинхронный загрузчик
уже вызван. Черт, неужели невозможно обойти эту проблему?

## Решение

К сожалению, эта проблема вызвана дизайном angular-translate. Все, что мы можем сделать для 
избежания этой проблемы - это переписать конфигурацию нашего модуля так, чтобы он вообще **не**
использовал асинхронный загрузчик. Ведь если асинхронный загрузчик не используется, то не происходит 
асинхронных запросов и, соответственно, не возникает ошибок.

Итак, как же нам переписать конфигурацию нашего модуля при тестировании? При создании модуля angular
мы всегда можем задать inline функцию, которую следует использовать для задания конфигурации.
Поскольку тут мы имеем доступ ко всем провайдерам, эта функция может быть использована в том числе и
для перезаписи настроек используемых модулей.

С помощью провайдера `$provide` мы можем создать свой собственный загрузчик и использовать его
вместо загрузчика статических файлов.

<pre>
beforeEach(module('myApp', function ($provide, $translateProvider) {

  $provide.factory('customLoader', function () {
    // loader logic goes here
  });

  $translateProvider.useLoader('customLoader');

}));
</pre>

Этот код выполняется **перед** каждым тестом. Тоесть, другими словами, мы можем переназначить
используемый при тестировании загрузчик. Теперь нам остается создать загрузчик, который не делает
асинхронных запросов к серверу:

<pre>
beforeEach(module('myApp', function ($provide, $translateProvider) {

  $provide.factory('customLoader', function ($q) {
    return function () {
      var deferred = $q.defer();
      deferred.resolve({});
      return deferred.promise;
    };
  });

  $translateProvider.useLoader('customLoader');

}));
</pre>

Вот так! Кроме того, можно просто постоянно предоставлять вашим приложениям переводы для
предпочитаемого языка в виде статического JSON:

<pre>
beforeEach(module('myApp', function ($translateProvider) {

  $translateProvider.translations('en', {});
}));
</pre>
