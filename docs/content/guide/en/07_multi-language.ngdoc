@ngdoc overview
@name Multi Language
@description

# Multi Language

In [Variable replacement](#/guide/06_variable-replacement) you've learned how to
pass dynamic values through the different components to make use of them within
your translations. Since we've covered all the basic functionality these components
provide (using the default interpolation service), we are now ready to get to the
next level: **Multi Language Support**.

Of course, it's pretty cool to know how to use the components angular-translate
provides, but things get really interesting when it comes to teach your apps more 
than just one language (which is actually what this module is for!). So let's get 
started by learning how to add different translation tables add a time!

## Teaching your app more languages

In [Getting Started](#/guide/02_gettin-started) you learned how to add a translation
table to your app, using `$translateProvider` method `translations()`. The same 
method can be used to add more translation tables add a time. To do this, simply add
a language key with which angular-translate is able to match a translation table to
its corresponding language.

Adding a language key to a translation table is very simple. Instead of just passing
the table as the only argument in `$translations()`, you pass the language key as 
first argument and the translation table becomes the second argument. So adding a 
translation table with a language key looks something like this:

<pre>
// registers translation table with language key 'en'
$translateProvider.translations('en', {
  GREETING: 'Hello world!'
});
</pre>

Now, to add a second translation table for another language, let's say german, just
do the same with a different language key:

<pre>
// registers translation table with language key 'de'
$translateProvider.translations('de', {
  GREETING: 'Hallo Welt!'
});
</pre>

Isn't that simple? Your app now knows about two different languages. You can add
as many languages as needed, there's no limit. However, since there are now two
languages available, what language should the app use? angular-translate doesn't 
choose a language until you tell it to do so.

## Decide what language to use

Since you've now registered more than one translation table, `angular-translate`
needs to know which one to use. This is where a new method of `$translateProvider`
comes in. `preferredLanguage()` tells angular-translate which of the registered
languages should be used by default. It expects an argument with the value of 
the language key that points to a certain translation table. So, to tell an app
it should use German rather then English as the first language, add this bit of
code:

<pre>
// tells angular-translate to use German
$translateProvider.preferredLanguage('de');
</pre>

**Note:** It's possible to use `$translateProvider.uses()` to do this as well 
since it also sets the language. However, it turns out this is a bad practice 
when using asynchronous loaders in combination with a storage. In some cases,
this resulted in angular-translate making two asynchronous calls. You'll learn
more on these details later. To get around this, we introduced
`preferredLanguage()`. You should always use `preferredLanguage()` instead of
`uses()` on `$translateProvider`.

## Using a fall back language

This is all great but unfortunately the `preferredLanguage()` you just chose
is incomplete. So you would like `angular-translate` to try a second language
for these missing translations instead of displaying some empty or unformatted
strings. The new `fallbackLanguage()` feature lets you tell `angular-translate`
to do so. `angular-translate` will use another language in case it cannot find a
translation in the translation table currently in use. Its usage is the same as `preferredLanguage()`.

<pre>
// tells angular-translate to use English if translations are not
// available in German
$translateProvider.fallbackLanguage('en');
</pre>

## Switching the language at runtime

To switch the language at runtime, `$translate` service has a method
`uses()` which either returns the language key of the currently used language, 
or, when passing a language key as argument, tells angular-translate to use the
corresponding language. `$translate.uses()` also invokes asynchronous loaders
internally when using a language for which the translation table hasn't been
loaded yet. But more on that in 
[Asynchronous Loading](#/guide/08_asynchronous_loading).

A good use of `$translate.uses()` would be in a controller that controls the
change of a language. You just have to write a function on the scope that 
takes a language key and then use it to tell angular-translate to change to
that language.

<pre>
angular.module('myApp').controller('Ctrl', ['$translate', '$scope', function ($translate, $scope) {

  $scope.changeLanguage = function (langKey) {
    $translate.uses(langKey);
  };

}]);
</pre>

To get a feeling for how it would work in a sample app, we update our app
accordingly. First, we add another translation table for German and add 
two new translation id's for buttons we want to add later:

<pre>
var translationsEN = {
  HEADLINE: 'What an awesome module!',
  PARAGRAPH: 'Srsly!',
  PASSED_AS_TEXT: 'Hey there! I\'m passed as text value!',
  PASSED_AS_ATTRIBUTE: 'I\'m passed as attribute value, cool ha?',
  PASSED_AS_INTERPOLATION: 'Beginners! I\'m interpolated!',
  VARIABLE_REPLACEMENT: 'Hi {{name}}',
  BUTTON_LANG_DE: 'german',
  BUTTON_LANG_EN: 'english'
};

var translationsDE= {
  HEADLINE: 'Was für ein großartiges Modul!',
  PARAGRAPH: 'Ernsthaft!',
  PASSED_AS_TEXT: 'Hey! Ich wurde als text übergeben!',
  PASSED_AS_ATTRIBUTE: 'Ich wurde als Attribut übergeben, cool oder?',
  PASSED_AS_INTERPOLATION: 'Anfänger! Ich bin interpoliert!',
  VARIABLE_REPLACEMENT: 'Hi {{name}}',
  BUTTON_LANG_DE: 'deutsch',
  BUTTON_LANG_EN: 'englisch'
};
</pre>

After that, we update the registration of the English translation table so it
has a corresponding language key and tell angular-translate to use English as
the default language:

<pre>
$translateProvider.translations('en', translationsEN);
$translateProvider.translations('de', translationsDE);
$translateProvider.preferredLanguage('en');
</pre>

Cool! Now we need controls to change the language at runtime. We update our HTML
and add a button for each language. We also setup an `ng-click` directive on each
button that calls a function to change the language:

<pre>
<button ng-click="changeLanguage('de')" translate="BUTTON_LANG_DE"></button>
<button ng-click="changeLanguage('en')" translate="BUTTON_LANG_EN"></button>
</pre>

Last but not least, we have to write the function in charge of changing the
language in our controller's scope:

<pre>
app.controller('Ctrl', ['$translate', '$scope', function ($translate, $scope) {

  $scope.changeLanguage = function (langKey) {
    $translate.uses(langKey);
  };
}]);
</pre>

Et voilá! We now have an app with multi language support!


<doc:example module="myApp">
  <doc:source>
    <script>
      var translationsEN = {
        HEADLINE: 'What an awesome module!',
        PARAGRAPH: 'Srsly!',
        PASSED_AS_TEXT: 'Hey there! I\'m passed as text value!',
        PASSED_AS_ATTRIBUTE: 'I\'m passed as attribute value, cool ha?',
        PASSED_AS_INTERPOLATION: 'Beginners! I\'m interpolated!',
        VARIABLE_REPLACEMENT: 'Hi {{name}}',
        MISSING_TRANSLATION: 'Oops! I have not been translated into german...',
        BUTTON_LANG_DE: 'german',
        BUTTON_LANG_EN: 'english'
      };

      var translationsDE= {
        HEADLINE: 'Was für ein großartiges Modul!',
        PARAGRAPH: 'Ernsthaft!',
        PASSED_AS_TEXT: 'Hey! Ich wurde als text übergeben!',
        PASSED_AS_ATTRIBUTE: 'Ich wurde als Attribut übergeben, cool oder?',
        PASSED_AS_INTERPOLATION: 'Anfänger! Ich bin interpoliert!',
        VARIABLE_REPLACEMENT: 'Hi {{name}}',
        // MISSING_TRANSLATION is ... missing :)
        BUTTON_LANG_DE: 'deutsch',
        BUTTON_LANG_EN: 'englisch'
      };

      var app = angular.module('myApp', ['pascalprecht.translate']);

      app.config(['$translateProvider', function ($translateProvider) {
        // add translation tables
        $translateProvider.translations('en', translationsEN);
        $translateProvider.translations('de', translationsDE);
        $translateProvider.preferredLanguage('en');
        $translateProvider.fallbackLanguage('en');
      }]);

      app.controller('Ctrl', ['$translate', '$scope', function ($translate, $scope) {

        $scope.changeLanguage = function (langKey) {
          $translate.uses(langKey);
        };
      }]);
    </script>
    <div ng-controller="Ctrl">
      <h2>{{ 'HEADLINE' | translate }}</h2>
      <p>{{ 'PARAGRAPH' | translate }}</p>

      <p translate>PASSED_AS_TEXT</p>
      <p translate="PASSED_AS_ATTRIBUTE"></p>
      <p translate>{{ 'PASSED_AS_INTERPOLATION' }}</p>
      <p translate="{{ 'PASSED_AS_INTERPOLATION' }}"></p>
      <p translate="VARIABLE_REPLACEMENT" translate-values="{ name: 'PascalPrecht' }"></p>
      <p translate>MISSING_TRANSLATION</p>

      <button ng-click="changeLanguage('de')" translate="BUTTON_LANG_DE"></button>
      <button ng-click="changeLanguage('en')" translate="BUTTON_LANG_EN"></button>
    </div>
  </doc:source>
</doc:example>

<br>
<hr>
<center>Made with unicorn &hearts; love by [PascalPrecht](http://github.com/PascalPrecht)</center>
