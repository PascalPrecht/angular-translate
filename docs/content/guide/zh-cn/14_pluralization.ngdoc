@ngdoc 概述
@name 多元化
@description

# 多元化

哇，我们已经走过远！我们已经学会了所有有关angular-translate提供的不同组件，我们知道如何在同一时间推出许多翻译表。
此外，我们利用不同类型的存储区，让我们的应用程序记住了交叉http请求的语言以及最后但并非最不重要的，我们使用异步装载机
异步从服务器加载我们的翻译资料！哇！

但还是有一件事我们还没有谈到: **多元化**. 当谈到本地化（localization）和国际化（i18n) 时多元化是一个相当困难的话题。
不同的语言和文化在某些情况下对如何使用语言有不同的解释。幸运的是我们有一个[标准](http://userguide.icu-project.org/formatparse/messages)。
但是，这并不改变的一个事实，这是一个很具挑战的实施。

幸运的是， [Alex Sexton](https://github.com/SlexAxton) 已经做了工作，并建立了一个JavaScript的库实现了_ICU User Guide_ spec。
这就是 MessageFormat， 你可以在[这里](https://github.com/SlexAxton/messageformat.js)找到。

## angular-translate 遇到 MessageFormat

在我们看来，给人们带来多元化，以angular-translate 最好的办法就是去采用MessageFormat中的功能性，因为它解决了所有问题，包括
[简单的变量替换](https://github.com/SlexAxton/messageformat.js#simple-variable-replacement),
[选择格式](https://github.com/SlexAxton/messageformat.js#selectformat),
和 [复数格式](https://github.com/SlexAxton/messageformat.js#pluralformat).
那么我们如何在我们的应用程序中使用在angular-translate中使用MessageFormat来借此充分发挥其优势呢？

当然，这有它相应的扩展。只需通过bower 安装MessageFormat：

```
$ bower install angular-translate-interpolation-messageformat
```

好吧，简单。不要忘了将它嵌入在你的HTML文档中，这样我们才可以使用所提供的服务。不要忘了先嵌入MessageFormat.js本身：

<pre>
<script src="path/to/messageformat.js"></script>
<script src="path/to/angular-translate-interpolation-messageformat"></script>
</pre>

**注：请务必通过嵌入MessageFormat中提供相应的语言环境的文件。这些文件提供了这是需要得到特定区域设置区域设置规则
适当的多元化！**

万事俱备后， 我们可以用 `$translateProvider`来告诉angular-translate 去使用MessageFormat内插服务，而不是用缺省的。
`$translateProvider`提供一个叫做`useMessageFormatInterpolation()`的方法来实现这个功能。
我们还必须再次使用 `$translateProvider.preferredLanguage()`， 这是为了让MessageFormat知道用什么语言环境
[named keys](https://github.com/SlexAxton/messageformat.js#named-keys).

<pre>
$translateProvider.useMessageFormatInterpolation();
$translateProvider.preferredLanguage('en');
</pre>

就是这些了！您的应用程序现在使用的MessageFormat来针对可能的值内插你的翻译。
那么，这是什么意思呢？既然你现在是依靠essageFormat的内插值而不是默认的内插，你现在可以使用 MessageFormat.js来预计内插值给您的翻译。

让我们看看一些在其README文件中提供的MessageFormat的例子。
这是有些翻译可能的形式：

```
{
  "LIKE_TEXT": "{GENDER, select, male{He} female{She} other{They}} liked this."
}
```

正如你所看到的，在给定的例子里， MessageFormat支持的`SelectFormat`来内插给定的性别。我们可以使用`$translate`翻译服务，以及
`translate`翻译指令和过滤器，去翻译`LIKE_TEXT`的翻译ID，如我们总是这样做：

<pre>
// using `$translate` service来
$translate('LIKE_TEXT', { GENDER: 'male' });
// using `translate` filter
{{ 'LIKE_TEXT' | translate:"{ GENDER: 'male' }" }}
// using `translate` directive
<ANY translate="LIKE_TEXT" translate-values="{ GENDER: 'male' }"></ANY>
</pre>

这很酷？您只需在angular-translate中插上MessageFormat的功能然后再您的翻译中使用高层次多元化！

## 缺点

其实它很酷，我们能够使用的MessageFormat作为我们的插补发动机。不幸的是，当更换MessageFormat的内插
为angular-translate的默认内插，还有一个很大的问题。来看看下面的代码， 你看到什么区别？

```
{
  "DEFAULT_INTERPOLATION": "This is a translation that uses default interpolation with a dynamic value: {{value}}",
  "MF_INTERPOLATION": "This is a translation that uses MessageFormat interpolation with a dynamic value: {value}"
}
```

没错。 MessageFormat中它的插值使用不同的语法。这意味着，在使用MessageFormat插补时，你必须检查你所有的翻译，
如果他们使用任何类型的变量替换，你要更新它们相匹配的内插语法。这是不是一件很酷的事情。

除此之外，我们也失去了所有Angular的很酷的功能，比如表达式求值或使用的过滤器，因为MessageFormat不支持
它们。那么，我们如何解决这个问题呢？我们需要一种方法来使用angular-translate的
默认的内插，去使用所有的很酷的功能，并同时我们需要MessageFormat中全功能的多元化支持。

## Overriding interpolation temporarily

Since it's a bit silly to re-implement MessageFormat's functionality within
angular-translate, we can't really use both interpolation types in a single translation.
But we _can_ use one interpolation type application-wide
and other interpolation types in specific cases. This means you would say for example:
"_Please use default interpolation for all of my translations, except for translation
A, B and C_".

With that construct you're able to use all the cool features Angular provides
with its interpolation service and in addition you can use MessageFormat interpolation
for translation IDs containinig pluralization.

So how do we get this working? It's easy. Seriously. Once you have installed
MessageFormat and its interpolation service, you actually have
everything you need. All you have to do, is to say you don't want to use
MessageFormat interpolation for all of your translations, but for specific
translations only.

At first, we remove `$translateProvider.useMessageFormatInterpolation()` again. Now our app
uses default interpolation. Alright. Next, we have to make MessageFormat
interpolation available as optional interpolation type. `$translateProvider`
has a method `addInterpolation()` which expects a factory name for an interpolation
service as first argument.

Let's add MessageFormat interpolation service as an 'optional' interpolation type:

<pre>
$translateProvider.addInterpolation('$translateMessageFormatInterpolation');
</pre>

Okay, now, our app is configured using the default interpolation, but is also aware
that there's another interpolation service that could be used for specific
translations. We setup a new translation table with translations that use default
interpolation and MessageFormat interpolation:

<pre>
$translateProvider.translations('en', {
  HEADLINE: 'I\'m a headline',
  TEXT: 'I\'m using default interpolation {{ val + val }}',
  PLURAL: '{GENDER, select, male{He} female{She} other{They}} liked this.'
});
</pre>

Okay, our translation table now contains translations that use either default
interpolation or MessageFormat interpolation. In order to tell angular-translate
which interpolation type should be used when using `$translate` service , we can
pass an additional parameter to angular-translate's components.

The `$translate` service expects an interpolation type as third argument. If you want
to configure the `$translate` service to use MessageFormat interpolation for the given
translation ID, you have to pass `messageformat` as interpolation type, like this:

<pre>
$translate('TEXT', { val: 5 });
// "I'm using default interpolation 10"

$translate('PLURAL', { GENDER: 'male' }, 'messageformat');
// "He liked this."
</pre>

We can achieve the same with `translate` filter. As explained earlier, the third
argument is an identifier for the interpolation service:

<pre>
{{ 'TEXT' | translate:"{ val: 5 }" }}
// "I'm using default interpolation 10"
{{ 'PLURAL' | translate:"{ GENDER: 'male' }":"messageformat" }}
// "He liked this."
</pre>

`translate` directive expects a new attribute called `translate-interpolation`
with which you can control which interpolation service to use for a specific
translation ID:

<pre>
<ANY
  translate="TEXT"
  translate-values="{ val: 5 }"></ANY>
// "I'm using default interpolation 10"

<ANY
  translate="PLURAL"
  translate-values="{ GENDER: 'male' }"
  translate-interpolation="messageformat"></ANY>
// "He liked this."
</pre>

Here is a working example (please note: There is also an embedded file for locale 'de'):

<doc:example module="myApp">
  <doc:source>
    <script>
      var app = angular.module('myApp', ['pascalprecht.translate']);

      app.config(['$translateProvider', function ($translateProvider) {
        $translateProvider.preferredLanguage('en');
        $translateProvider.addInterpolation('$translateMessageFormatInterpolation');

        $translateProvider.translations('en', {
          HEADLINE: 'I\'m a headline',
          TEXT: 'I\'m using default interpolation {{ val + val }}',
          PLURAL: '{GENDER, select, male{He} female{She} other{They}} liked this.',
          BUTTON_LANG_EN: 'english',
          BUTTON_LANG_DE: 'german'
        });

        $translateProvider.translations('de', {
          HEADLINE: 'Ich bin eine Überschrift',
          TEXT: 'Ich benutze default interpolation {{ val + val }}',
          PLURAL: '{GENDER, select, male{Er fand} female{Sie fand} other{Sie fanden}} es gut.',
          BUTTON_LANG_EN: 'englisch',
          BUTTON_LANG_DE: 'deutsch'
        });
      }]);

      app.controller('Ctrl', ['$translate', '$scope', function ($translate, $scope) {

        $scope.changeLanguage = function (langKey) {
          $translate.use(langKey);
        };
      }]);
    </script>
    <div ng-controller="Ctrl">
      <p translate="HEADLINE"></p>
      <p translate="TEXT" translate-values="{ val: 5 }"></p>

      <p translate="PLURAL" translate-values="{ GENDER: 'other' }" translate-interpolation="messageformat"></p>

      <button ng-click="changeLanguage('de')" translate="BUTTON_LANG_DE"></button>
      <button ng-click="changeLanguage('en')" translate="BUTTON_LANG_EN"></button>
    </div>
  </doc:source>
</doc:example>

<br>
<hr>
<center>Made with unicorn &hearts; love by [PascalPrecht](http://github.com/PascalPrecht)</center>
