@ngdoc 概述
@name 回退语言
@description

# 回退语言

现在你可能会问，你读过之后，你可以配置首选语言和
注册多语言具有多语言支持, 如果有一种方法来教您的应用程序回退语言。 答案是肯定的。

## 注册一个回退语言

教你的应用程序中使用回退语言就是简单的调用一个`$translateProvider`的方法. 没错吧，这听起来太简单了，但是就是这样的。
比方说，我们有一个应用程序，我们注册一个翻译表为德语。

<pre>
$translateProvider
  .translations('de', { /* ... */ });
</pre>

Now let's say there are some translation ids, that **are** available in an english
translation table, but not in the german translation table. angular-translate
would generally return the given translation id, if it can't find a translation
for it in the translation table. If you register a fallback language that has the
translation id in it, angular-translate will return this translation instead.

So let's register english as a fallback language for our app, first we have to
register the language itself for sure.

<pre>
$translateProvider
  .translations('de', { /* ... */ })
  .translations('en', { /* ... */ });
</pre>

Now we tell angular-translate to use english as a fallback language:

<pre>
$translateProvider
  .translations('de', { /* ... */ })
  .translations('en', { /* ... */ })
  .fallbackLanguage('en');
</pre>

That's it. If there isn't a translation id in the german translation table,
angular-translate will search for it in the english translation table. Easy huh?

## Registering a fallback stack

Now what if you have a set of fallback languages? angular-translate can handle these
too! All you have to do is to register your fallback language keys as array:

<pre>
$translateProvider
  .translations('de', { /* ... */ })
  .translations('en', { /* ... */ })
  .translations('fr', { /* ... */ })
  .fallbackLanguage(['en', 'fr']);
</pre>

Now, if angular-translate can't find your translation id in the english translation
table, which is the first fallback language, it iterates over the rest of registered
fallback languages and searches there. This is a one way ticket, which means the
iteration starts in this case at `en` and goes on until `fr`. You can register as
many fallback language as you want.

## Switching fallback language at runtime

Oh yes even **that** is possible! There are some cases where you might want to switch
your fallback language at runtime too. Or even the entire fallback stack! For example
imagine the case where you set german as preferred language and you want to make sure
that english is the fallback language. No problem. We can do that already. Now imagine,
the actual language is switched to english and you want to fallback to french, but
english is already registered as fallback language.

You can switch the fallback language at runtime with the `fallbackLanguage()` method
on the `$translate` service. Here's how it could look like:

<pre>
$scope.changeLanguage = function (langKey) {
  if (langKey === 'en') {
    $translate.fallbackLanguage('fr');
  } else if (langKey == 'de') {
    $translate.fallbackLanguage('en');
  }
  $translate.use(langKey);
};
</pre>

Don't forget that the fallback language key controls the start point of the iteration
for fallback languages. If you have `en, fr, de` as fallback language registered and
  you switch the fallback language to `fr`, in that case, if there's a missing
translation id, angular-translate only searches in `de` for a fallback translation.

## Changing the entire fallback stack at runtime

Same as above you can do:

<pre>
$scope.changeLanguage = function (langKey) {
  $translate.fallbackLanguage(['de', 'en', 'fr']);
  $translate.use(langKey);
};
</pre>

When changing the entire fallback language stack, you also change the order in how
angular-translate iterate over them. So actually, the iteration process stays the same
but you change the order of fallback languages to iterate over.

## Limit the fallback languages to iterate

An additional possibility to iterate through the fallback stack is to limit the languages to be
scanned for translation keys. There are some use cases where the user / developer wants to scan
only a part of the available fallback languages without removing some already defined or loaded
languages. This is also possible!
As mentioned above, the fallback stack is iterated from 'left to right'. So if we would like to
start the iteration after 'de' in the stack of 'de, en, fr', we have to define the start with
'useFallbackLanguage()'.

<pre>
  // langKey is 'en'
  $scope.changeLanguage = function (langKey) {
  $translate.fallbackLanguage(['de', 'en', 'fr']);
  $translate.useFallbackLanguage(langKey);
};
</pre>

From now on - all translation texts in 'de' will be ignored and skipped.
Important notice: If the ignored language is the preferred or current translation, it will be
translated within that language - even though it should be skipped!
<br>
<hr>
<center>Made with unicorn &hearts; love by [PascalPrecht](http://github.com/PascalPrecht)</center>
