@ngdoc 概述
@name 异步加载
@description

# 异步加载

Okay, different translations for different languages is pretty cool. But it's
even better if you're able to load translations asynchronously right?
`angular-translate` has some pretty cool extensions to support asynchronous and
lazy loading of translation data. And it works like a charm.

## Asynchronous loaders
angular-translate provides a pretty clever way to tell $translate service to
load data asynchronously. To load your data from a server you have to use an
asynchronous loader, which gets invoked later at runtime when it's needed.
angular-translate comes with support for three different asynchronous loaders. Both
of them are installable via Bower. Let's take a look at them!

## 使用 urlLoader
这是可能的装载换算数据的异步最简单的方法。所有您需要做的，
就是用 bower 安装 `angular-translate-loader-url`扩展：

```
$ bower install angular-translate-loader-url
```

安装完成后，请确认你已经在HTML文档中内嵌了。
好吧， 装载机是可用的，我们现在要告诉angular-translate 去使用它。
`$translateProvider` 提供一个方法叫做 `useUrlLoader()`. 很简单对吧? 、
`useUrlLoader()` 预期一个描述端点的参数。他将与那服务器进行翻译数据响应。

此外，使用异步加载器的时候，我们必须使用`$translateProvider.preferredLanguage()`, 让angular-translate
知道哪些语言应该载入翻译数据。

<pre>
$translateProvider.useUrlLoader('foo/bar.json');
$translateProvider.preferredLanguage('en');
</pre>

所以，这里会发生什么？ angular-translate 使用扩展改造给定的字符串，
到稍后可以在运行时调用一个真正的加载函数，
一旦`$translate`服务启动. 同时告诉angular-translate去使用语言键值'en',
增加了语言键值参数给定的加载程序的字符串。

所以，上面的例子中实际请求 `foo/bar.json?lang=en`. angular-translate
还注意到，可在启动时没有任何翻译数据，并将尽快自动调用加载器。

## 使用staticFilesLoader

如果您有不只有一个URL期待`lang`参数来返回一个JSON，其中包含记得翻译，而是有多个本地化文件匹配一个特定的模式，
你可能想使用`angular-translate-loader-static-files`扩展，它描述您的本地化文件模式。

和urlLoader一样, 你可以使用 bower 安装 staticFilesLoader:

```
$ bower install angular-translate-loader-static-files
```

一旦软件包安装和嵌入，则可以使用 `$translateProvider`方法`useStaticFilesLoader()`来告诉angular-translate去使用它.
静态文件加载器的工作原理有点不同。不只是具有固定url需要一个`lang`参数，你现在可以有不同的本地化匹配特定模式的文件

如何定义模式取决于您的需要。要指定一种模式，以下信息是必需的：

* **prefix** - 指定文件前缀
* **suffix** - 指定文件后缀

比方说，你有两个本地化文件 `locale-de.json` 和 `locale-en.json`.
你可以简单地这样使用staticFilesLoader：

<pre>
$translateProvider.useStaticFilesLoader({
    prefix: 'locale-',
    suffix: '.json'
});
$translateProvider.preferredLanguage('en');
</pre>

angular-translate 将连接所提供的资料成为这个格式
`{{prefix}}{{langKey}}{{suffix}}`。 所以这样会加载 `locale-en.json`.
同时因为有没有任何翻译数据，它会尽快装入这样可以自动完成。

## 使用 partialLoader
在一个更大的复杂应用程序时，您通常会组织你的应用程序下为几个
子模块。例如，你可以有一个模块`mainAPP`这个模块依赖于'home'和'contact'模块。
这只是两个子模块，但现在想象一下，你有一个非常大的应用程序依赖于10或20个子模块！

在这样的应用程序也许20子模块里面13个永远不会被执行，因为用户
总是走不到那里。然而，翻译这么大的应用程序内容时，其中
也许并不总是执行的大约占50％的应用程序，在不同的语言下加载所有的翻译数据不是非常酷的加载方式。

我们需要的，是一种方法，只需要加载我们当前米啊对的一个语言的翻译数据。
这意味着，访问`home`子模块时，我们只是要加载的数据转换为`home`模块。
如果我们改变语言，我们也只是想加载选择语言下的`home`模块的翻译。

What we need, is a way to just load the translation data of a language for a specific
module we're currently on. Which means, when accessing the `home` submodule,
we just want to load the translation data for the `home` module. If we change the
language, we also just want to load the translation for the choosed language for
the `home` module.

In addition, when we've already loaded translation data for let's say three
different modules, and change the language and then change the language again
to the language we already had, we don't want to load the data again, because
we already loaded it a little while ago.

Yea, these are all the things we have to care about when we wanna have partial
loading. However, `angular-translate` got your covered. This is where
`partialLoader` comes in.

You can install it like every other loader by simply using Bower:

```
$ bower install angular-translate-loader-partial
```

When using `partialLoader` you have to think about which pattern
`angular-translate` should use to load your translation data. It's similar to
`staticFilesLoader` but a bit more specifc. You have to specify a `part` and
a `lang` property, where `part` is your specifc part of your app (maybe `home`)
and `lang` is the lang key just as you know.

Let's say we've structured our translation files by module and the files look
ike this:

```
/i18n/home/en.json
/i18n/home/de.json
/i18n/contact/en.json
/i18n/contact/de.json
```

Pretty straight forward ha? Now that we know how our data is structured, we
can configure `$translateProvider` to use the partial loader with this pattern:

<pre>
$translateProvider.useLoader('$translatePartialLoader', {
  urlTemplate: '/i18n/{part}/{lang}.json'
});
</pre>

Almost done! Of course `angular-translate` has to know which language to use, which
is why we add the following:

<pre>
$translateProvider.preferredLanguage('en');
</pre>

Okay, nothing new. Now it gets interesting. How does `angular-translate` know
which "part" to load? To make it short: it can't. You have to tell
`angular-translate` **which part** you want to load **when**.

`partialLoader` comes with a `provider` you can use to configure the inital
state of the loader. So, to use this provider we have to inject it into our
config function:

<pre>
angular.module('main')
.config(function ($translateProvider, $translatePartialLoaderProvider) {

});
</pre>

Allright. Now, to let `angular-translate` know which part it should load,
we use `$translaterPartialLoaderProvider`'s `addPart()` method. So we simply
say something like:

<pre>
$translatePartialLoaderProvider.addPart('home');
$translateProvider.useLoader('$translatePartialLoader', {
  urlTemplate: '/i18n/{part}/{lang}.json'
});
$translateProvider.preferredLanguage('en');
</pre>

As you can see, the whole functionality for partial loader sits in the provided
loader, rather then `angular-translate` itself. The pattern is now complete and
`angular-translate` will execute the loader as soon as possible.

Okay, so this is the inital process but what about runtime? What if a user comes
accross the `contact` module and we only want to load the translation data for
the current language for the `contact` module?

`$translatePartialLoaderProvider` configures `$translatePartialLoader` which means
you're able to inject `$translatePartialLoader` into your controllers and services
to make use of it. But why do you want to? As you can add a translation part to
the loader via the provider, you can also do so with the provided service to
manipulate loader state at runtime. So what does that mean? It means, you just
have to inject the loader and use that one to add additional translation parts.

Let's say we have a `ContactCtrl` within our `contact` module, things could look
like this:

<pre>
angular.module('contact')
.controller('ContactCtrl', function ($scope, $translatePartialLoader) {
  $translatePartialLoader.addPart('contact');
});
</pre>

That wasn't hard, right? So what happens here is we manipulate our loaders state
during runtime. This makes sure that angular-translate only loads specific
translation data when we really want to. Once you added a new part,
`$translatePartialLoader` fires an `$translatePartialLoaderStructureChanged`
event.

Until now there's no additional data loaded! `angular-translate` doesn't know
about the loaders state so you have to tell `angular-translate` to **refresh**
the current translation tables. Refreshing translation tables drops
(if no table is specified) and reloads them. So basically, to achieve partial
loading, all you have to do is to manipulate the state of the loader by saying
which parts to add and then refreshing the tables. Because, when changing the
loaders state with new parts, they get loaded the next time the loader gets
invoked.

So all we have to do is simply adding the following:

<pre>
angular.module('contact')
.controller('ContactCtrl', function ($scope, $translatePartialLoader, $translate) {
  $translatePartialLoader.addPart('contact');
  $translate.refresh();
});
</pre>

You can also use the `$translatePartialLoaderStructureChanged` event to automate
the process, by listening to that event with `$rootScope` and refreshing
translation tables everytime it gets fired.

<pre>
app.run(function ($rootScope, $translate) {
  $rootScope.$on('$translatePartialLoaderStructureChanged', function () {
    $translate.refresh();
  });
});
</pre>

Since `$translate.refresh()` returns a promise, it works beautifully together
with either `ngRoute` module or UI Router.

## Lazy loading at runtime

Once your app bootstraps, it'll load needed translation data asynchronously as
soon as possible. Okay, cool. But what if a user wants to change the language and
the corresponding translation data isn't also loaded yet?

In [Multi Language](#/guide/07_multi-language) you've learned, how to change the
language at runtime using `$translate.use()`. Know what? Nothing will change when
dealing with asynchronous loaders. `$translate.use()` checks if a translation
table for a given language key is present or not. And if not, it'll invoke the
registered loader to get it down! Lazy loading at it best!

**Note**: Please notice that in case of using `partialLoader` you have to refresh
translation tables first!

## FOUC - Flash of untranslated content

There's one drawback when using asynchronous loaders to get your translation data
into the app. There's a little amount of time when your app launches where you
have this little kind of flickering, because your translation data isn't loaded
yet. This is actually not a bug of angular-translate, but a pretty logical behavior
since we return executing stuff asynchronously.

To get around this, you could provide at least one language **with** your app
without having to load it asynchronously. If your app then uses this provided
language as default language, using `$translateProvider.preferredLanguage()`, you
won't have this FOUC, because the language to use is already there.

Just use a combination of `$translateProvider.translations()` and
`$translateProvider.{{whatever}}Loader` like this:

<pre>
$translateProvider.translations('en', {
    'HELLO_TEXT': 'Hello World!'
});
$translateProvider.useStaticFilesLoader({
    'prefix': 'locale-',
    'suffix': '.json'
});
$translateProvider.preferredLanguage('de');
</pre>

Let's update our sample app accordingly to use an asynchronous loader! We'll use
the staticFilesLoader. First, we have to pull the translation tables out of the
code and put them into separate locale files:

**Note:** The data is now provided as _JSON_ so make sure to put everything in
double quotes! Also make sure to NOT copy the comment and let your server send
JSON as JSON not as plain text!

<pre>
// locale-en.json
{
  "HEADLINE": "What an awesome module!",
  "PARAGRAPH": "Srsly!",
  "PASSED_AS_TEXT": "Hey there! I'm passed as text value!",
  "PASSED_AS_ATTRIBUTE": "I'm passed as attribute value, cool ha?",
  "PASSED_AS_INTERPOLATION": "Beginners! I'm interpolated!",
  "VARIABLE_REPLACEMENT": "Hi {{name}}",
  "BUTTON_LANG_DE": "german",
  "BUTTON_LANG_EN": "english"
}
</pre>

<pre>
// locale-de.json
{
  "HEADLINE": "Was für ein großartiges Modul!",
  "PARAGRAPH": "Ernsthaft!",
  "PASSED_AS_TEXT": "Hey! Ich wurde als text übergeben!",
  "PASSED_AS_ATTRIBUTE": "Ich wurde als Attribut übergeben, cool oder?",
  "PASSED_AS_INTERPOLATION": "Anfänger! Ich bin interpoliert!",
  "VARIABLE_REPLACEMENT": "Hi {{name}}",
  "BUTTON_LANG_DE": "deutsch",
  "BUTTON_LANG_EN": "englisch"
}
</pre>

Next we setup `$translate` service using `$translateProvider`:

<pre>
// configures staticFilesLoader
$translateProvider.useStaticFilesLoader({
  prefix: 'data/locale-',
  suffix: '.json'
});
// load 'en' table on startup
$translateProvider.preferredLanguage('en');
</pre>

Since we don't have to make any changes in our controllers or HTML, we are done!
Take a look at the working app:

<doc:example module="myApp">
  <doc:source>
    <script>
      var app = angular.module('myApp', ['ngCookies', 'pascalprecht.translate']);

      app.config(['$translateProvider', function ($translateProvider) {
        $translateProvider.translations('en', {
          "HEADLINE": "What an awesome module!",
          "PARAGRAPH": "Srsly!",
          "PASSED_AS_TEXT": "Hey there! I'm passed as text value!",
          "PASSED_AS_ATTRIBUTE": "I'm passed as attribute value, cool ha?",
          "PASSED_AS_INTERPOLATION": "Beginners! I'm interpolated!",
          "VARIABLE_REPLACEMENT": "Hi {{name}}",
          "BUTTON_LANG_DE": "german",
          "BUTTON_LANG_EN": "english"
        });
        // configures staticFilesLoader
        $translateProvider.useStaticFilesLoader({
          prefix: 'data/locale-',
          suffix: '.json'
        });
        // load 'en' table on startup
        $translateProvider.preferredLanguage('en');
      }]);

      app.controller('Ctrl', ['$translate', '$scope', function ($translate, $scope) {

        $scope.changeLanguage = function (langKey) {
          $translate.use(langKey);
        };
      }]);
    </script>
    <div ng-controller="Ctrl">
      <p>{{ 'HEADLINE' | translate }}</p>
      <p>{{ 'PARAGRAPH' | translate }}</p>

      <p translate>PASSED_AS_TEXT</p>
      <p translate="PASSED_AS_ATTRIBUTE"></p>
      <p translate>{{ 'PASSED_AS_INTERPOLATION' }}</p>
      <p translate="{{ 'PASSED_AS_INTERPOLATION' }}"></p>
      <p translate="VARIABLE_REPLACEMENT" translate-values="{ name: 'PascalPrecht' }"></p>

      <button ng-click="changeLanguage('de')" translate="BUTTON_LANG_DE"></button>
      <button ng-click="changeLanguage('en')" translate="BUTTON_LANG_EN"></button>
    </div>
  </doc:source>
</doc:example>

Open up your browser's devtools and take a look at the network activities when changing
the language. Our app now loads translation data asynchronously! In the next
chapter you'll learn how to build **your own custom loaders**.

<br>
<hr>
<center>Made with unicorn &hearts; love by [PascalPrecht](http://github.com/PascalPrecht)</center>
