@ngdoc overview
@name Модульне тестування
@description

# Модульне тестування з angular-translate

Розробники AngularJS звертають увагу на тестованість коду. І нам це подобається. Тому ми тестуємо
angular-translate буквально з перших стадій розробки. Однак, при створенні AngularJS застосунків з
підтримкою інтернаціоналізації від angular-translate тестування вашого застосунку може дещо
ускладнитися. Це керівництво покаже вам як можна обійти найбільш поширені проблеми при написанні
модульних тестів для застосунка, що використовує angular-translate.

## У чому проблема?

Виходячи з досвіду розробки angular-translate, коли діло доходить до тестування виникає одна і та
сама проблема. Уявіть собі такий сценарій: Ви створюєте застосунок, що використовує не лише сам
angular-translate, але ще й асинхронний завантажувач (доволі поширена ситуація). Тоді конфігурація
вашого застосунку може виглядати так:

<pre>
app.config(function ($translateProvider) {
  $translateProvider
    .useStaticFilesLoader({
      prefix: 'locale-',
      suffix: '.json'
    })
    .preferredLanguage('en');
});
</pre>

У такому випадку ми використовуємо завантажувач статичних файлів для завантаження перекладів з
віддаленої точки доступу. Також ми говоримо angular-translate, що надаємо перевагу мові `en`. Все
доволі просто.

Давайте припустимо, що у нас є контроллер, який використовує сервіс `$translate` для перемикання
мови під час виконання застосунку (теж *дуже* поширено):

<pre>
app.controller('LanguageController', function ($scope, $translate) {
  $scope.switchLanguage = function (locale) {
    $translate.use(locale);
  });
});
</pre>

Добре. В тепер давайте подумаємо що станеться коли ми запустимо наш застосунок. Ось як все буде
відбуватися крок за кроком:

- ми реєструємо асинхронний завантажувач
- ми вказуємо мову, якій віддаємо перевагу
- сервіс `$translate` вперше створюється та впроваджується
- angular-translate помічає, що немає локально доступних мов
- він перевіряє чи зареєстровано асинхронний завантажувач
- асинхронний завантажувач викликається для мови, якій надається перевага
- переклади завантажуються і готові до використання

Корисно розуміти як працює angular-translate, щоб уявити собі які проблеми це може викликати. У
представленому вище процесі є один дуже важливий крок. Якщо зареєстровано асинхронний завантажувач,
а дані перекладів ще не закешовані, то angular-translate **неявно** викликає цей завантажувач. Чому
ж це може викликати проблеми при модульному тестуванні вашого застосунку?

Щоб це зрозуміти нам треба поглянути на те, як ми пишемо тести, наприклад, з Jasmine. Ми починаємо
з блоку `describe()` і завантажуємо наш angular застосунок для кожного тесту:

<pre>
describe('myApp', function () {

  beforeEach(module('myApp'));

});
</pre>

Завдяки цьому ми можемо бути впевнені, що в кожному конкретному тесті створено модуль нашого
застосунку. Після цього ми налаштовуємо наш `LanguageController` з підміною області видимості
приблизно так:

<pre>
describe('myApp', function () {

  beforeEach(module('myApp'));

  var LanguageCtrl, scope;

  beforeEach(inject(function ($controller, $rootScope) {
    scope = $rootScope.$new();

    LanguageCtrl = $controller('LanguageCtrl', {
      $scope: scope
    });
  }));

  it('should do something', function () {

  });
});
</pre>

Під час запуску цього тесту ми отримаємо наступну помилку:

```
Error: Unexpected request: GET locale-en.json
```

Але чому? Проблема в тому, що angular-translate неявно викликає асинхронний завантажувач. Це
означає, що при створенні сервісу `$translate` відбувається асинхронний запит на сервер, по 
відношенню до якого ми нічого не робимо.

При написанні тестів треба явно вказувати, що ми очікуємо виконання асинхронного запиту у кожному
конкретному випадку. Так робити правильно. Іншими словами, коли ми явно говоримо, що очікуємо
асинхронний запит, ця помилка не повинна виникати, так?

Давайте спробуємо обійти проблему шляхом впровадження сервісу `$httpBackend` для обробки асинхронних
запитів і підставляння відповідей:

<pre>
describe('myApp', function () {

  beforeEach(module('myApp'));

  var LanguageCtrl, scope, $httpBackend;

  beforeEach(inject(function ($controller, $rootScope, _$httpBackend_) {
    scope = $rootScope.$new();
    $httpBackend = _$httpBackend_;

    LanguageCtrl = $controller('LanguageCtrl', {
      $scope: scope
    });
  }));

  it('should do something', function () {
    $httpBackend.expectGET('locale-en.json');

    // test code goes here
  });
});
</pre>

Виявляється це теж не працює, тому що в момент виклику `expectGET()` асинхронний завантажувач вже
викликаний. Чорт, невже неможливо обійти цю проблему?

## Рішення

На жаль, ця проблема викликана дизайном angular-translate. Все, що ми можемо зробити для запобігання
цій проблемі - це переписати конфігурацію нашого модуля так, щоб він взагалі **не** використовував
асинхронний завантажувач. Адже якщо асинхронний завантажувач не використовується, то не відбувається
асинхронного запиту і, відповідно, не виникає помилок.

Тож, як же нам переписати конфігурацію нашого модуля при тестуванні? При створенні модуля angular ми
завжди можемо задати inline функцію, яку слід використовувати для задання конфігурації. Оскільки тут
ми маємо доступ до всіх провайдерів, ця функція може бути використана в тому числі і для перезапису
налаштувань модулів, що використовуються.

За допомогою провайдера `$provide` ми можемо створити свій власний завантажувач і використовувати
його замість завантажувача статичних файлів.

<pre>
beforeEach(module('myApp', function ($provide, $translateProvider) {

  $provide.factory('customLoader', function () {
    // loader logic goes here
  });

  $translateProvider.useLoader('customLoader');

}));
</pre>

Цей код виконується **перед** кожним тестом. Тобто, іншими словами, ми можемо переназначити
завантажувач, що використовується при тестуванні. Тепер нм залишається створити завантажувач, який
не робить асинхронний запитів до серверу:

<pre>
beforeEach(module('myApp', function ($provide, $translateProvider) {

  $provide.factory('customLoader', function ($q) {
    return function () {
      var deferred = $q.defer();
      deferred.resolve({});
      return deferred.promise;
    };
  });

  $translateProvider.useLoader('customLoader');

}));
</pre>

Ось так! Крім того, можна просто постійно надавати вашим застосункам переклади для мови, якій
надається перевага у вигляді статичного JSON:

<pre>
beforeEach(module('myApp', function ($translateProvider) {

  $translateProvider.translations('en', {});
}));
</pre>
